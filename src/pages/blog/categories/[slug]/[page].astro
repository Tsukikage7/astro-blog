---
import CollectionLayout from "@components/blog/CollectionLayout.astro";
import { getCollection } from "astro:content";
import { slugify } from "@lib/textConverter";
import { getPageSize } from "@lib/config";
import type { BlogEntry } from "@/types";

export async function getStaticPaths() {
  const allPosts = await getCollection("blog");

  
  const categoryPosts = new Map<string, any[]>();
  allPosts.forEach((post: any) => {
    const postCategories = post.data.categories;
    if (postCategories && postCategories.toString()) {
      const categoryName = postCategories.toString();
      const categorySlug = slugify(categoryName);
      if (!categoryPosts.has(categorySlug)) {
        categoryPosts.set(categorySlug, []);
      }
      categoryPosts.get(categorySlug)!.push({ post, categoryName });
    }
  });

  const paths: any[] = [];
  const entriesPerPage = getPageSize('blog');

  
  categoryPosts.forEach((posts, categorySlug) => {
    const categoryName = posts[0].categoryName;
    const sortedPosts = posts
      .map((p) => p.post)
      .sort((a, b) => {
        const dateA = a.data.created;
        const dateB = b.data.created;
        if (!dateA || !dateB) return 0;
        return new Date(dateB).getTime() - new Date(dateA).getTime();
      });

    const pageCount = Math.ceil(sortedPosts.length / entriesPerPage);

    
    for (let i = 1; i <= pageCount; i++) {
      const startIndex = (i - 1) * entriesPerPage;
      const endIndex = startIndex + entriesPerPage;
      const paginatedPosts = sortedPosts.slice(startIndex, endIndex);

      paths.push({
        params: {
          slug: categorySlug,
          page: i.toString(),
        },
        props: {
          categoryName,
          categoryPosts: paginatedPosts,
          currentPageIndex: i,
          pageCount,
          totalArticleCount: sortedPosts.length,
        },
      });
    }
  });

  return paths;
}

const {
  categoryName,
  categoryPosts,
  currentPageIndex,
  pageCount,
  totalArticleCount,
} = Astro.props;
const { slug, page } = Astro.params;
const entriesPerPage = getPageSize('blog');

const entries: BlogEntry[] = categoryPosts.map((post:any) => ({
  id: post.id,

  collection: "blog",
  body: post.body,
  data: {
    title: post.data.title,
    description: post.data.description,
    image: post.data.image,
    updatedAt: post.data.updated,
    categories: post.data.categories,
    tags: post.data.tags || [],
    featured: post.data.featured,
    recommended: post.data.recommended,
    views: post.data.views,
  },
}));

const allPosts = await getCollection("blog");

const categoryStats = new Map<string, number>();
allPosts.forEach((post) => {
  if (post.data.categories) {
    const cat = post.data.categories;
    if (cat && cat.toString()) {
      categoryStats.set(
        cat.toString(),
        (categoryStats.get(cat.toString()) || 0) + 1,
      );
    }
  }
});

const categories = Array.from(categoryStats.entries())
  .map(([name, count]) => ({
    name,
    slug: slugify(name),
    count,
  }))
  .sort((a, b) => a.name.localeCompare(b.name));

const tagStats = new Map<string, number>();
allPosts.forEach((post) => {
  if (post.data.tags && Array.isArray(post.data.tags)) {
    post.data.tags.forEach((tag) => {
      tagStats.set(tag, (tagStats.get(tag) || 0) + 1);
    });
  }
});
const tags = Array.from(tagStats.keys())
  .map((name) => ({
    name,
    slug: slugify(name),
  }))
  .sort((a, b) => a.name.localeCompare(b.name));

const entryIndex: BlogEntry = {
  id: "blog-category",
  collection: "blog" as const,
  data: {
    title: categoryName,
    description: `${categoryName}分类下的文章`,
    categories: categories.map((cat) => cat.name),
    featured: false,
    recommended: false,
    views: 0,
    created: new Date(),
    updated: new Date(),
  },
};
---

<CollectionLayout
  entryIndex={entryIndex}
  entries={entries}
  tags={tags.map((tag) => tag.name)}
  categories={categories}
  pageIndex={currentPageIndex}
  pageCount={pageCount}
  allBlogCount={totalArticleCount}
  basePath={`/blog/categories/${slug}`}
/>
