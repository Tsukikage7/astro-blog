---
import type { BlogEntry } from "@/types";
import TaxonLayout from "@components/blog/TaxonLayout.astro";
import { getCollection } from "astro:content";
import { slugify } from "@lib/textConverter";

export const prerender = true;

export async function getStaticPaths() {
  const allPosts = await getCollection("blog");

  
  const allTags = new Set<string>();
  allPosts.forEach(post => {
    if (post.data.tags && Array.isArray(post.data.tags)) {
      post.data.tags.forEach(tag => {
        allTags.add(tag);
      });
    }
  });

  
  return Array.from(allTags).map(tag => ({
    params: { slug: slugify(tag) },
    props: { taxon: tag }
  }));
}

const { taxon } = Astro.props;
const { slug } = Astro.params;

const allPosts = await getCollection("blog");

const entries: BlogEntry[] = allPosts
  .filter(post => {
    return post.data.tags && 
           Array.isArray(post.data.tags) && 
           post.data.tags.some(tag => slugify(tag) === slug);
  })
  .map(post => ({
    id: post.id,
    slug: post.id,
    body: post.body,
    collection: 'blog',
    data: {
      title: post.data.title,
      description: post.data.description,
      created: post.data.created,
      updatedAt: post.data.updated,
      image: post.data.image,
      categories: post.data.categories,
      tags: post.data.tags || [],
      featured: post.data.featured,
      recommended: post.data.recommended,
      views: post.data.views,
    }
  } as BlogEntry))
  .sort((a, b) => {
    const dateA = new Date(a.data.created!);
    const dateB = new Date(b.data.created!);
    return dateB.getTime() - dateA.getTime();
  });
---

<TaxonLayout taxon={taxon} entries={entries} />
